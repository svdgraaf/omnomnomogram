{
  "name": "properties",
  "version": "0.3.3",
  "description": ".properties parser/stringifier",
  "keywords": [
    "properties",
    ".properties",
    "ini",
    ".ini",
    "parser"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gaglekas@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Gagle/Node-Properties.git"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "buffered-reader": "*",
    "buffered-writer": "*",
    "error-provider": "*"
  },
  "devDependencies": {
    "mocha-runner": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.html"
    }
  ],
  "main": "lib/properties",
  "readme": "properties\r\n==========\r\n\r\n_Node.js project_\r\n\r\n#### .properties parser/stringifier ####\r\n\r\nVersion: 0.3.3\r\n\r\nThis module implements the Java .properties specification and gives to you a powerful set of features that can be enabled. Json files can be used to store complex data structures such as arrays or nested objects, but if you only want to save some properties, e.g. the database uri connection and credentials, valid json files can become a bit overloaded due to the metadata characters: curly braces, colons, commas and especially a lot of double quotes. Compare these two versions:\r\n\r\n```text\r\na = x\r\n[s1]\r\nb = y\r\n[s2]\r\nc = z\r\n```\r\n\r\n```javascript\r\n{\r\n\t\"a\": \"x\",\r\n\t\"s1\": {\r\n\t\t\"b\": \"y\"\r\n\t},\r\n\t\"s2\": {\r\n\t\t\"c\": \"z\"\r\n\t}\r\n}\r\n```\r\n\r\nWhich do you prefer? Which is more readable? Can you write comments in json files?\r\n\r\nThe properties are parsed the right way, reading character by character instead of reading lines, splitting them, using regular expressions and all the easy to implement but slow techniques.\r\n\r\nThere are several additional features you can use, some of them are: sections, variables, define your custom comment and key-value separator characters, replacers and revivers similar to the json callbacks, pretty print the stringified properties, convert special characters to their unicode string representation, write comments, parse/stringify INI files and much more.\r\n\r\nThe disk access is buffered to reduce the memory footprint. The default buffer size is 16KB, a quite large for a simple properties file. Most often you'll have small files (less than 1KB, maybe 2KB), so a single I/O call will be done, but it's better to support buffering, just in case. If you prefer, you can avoid the buffers and work with strings with the [parse()](#parse) and [stringify()](#stringify) functions, so you decide how to do the I/O access -typically you'll use fs.readFile() and fs.writeFile()-. \r\n\r\nThe properties are case sensitive.\r\n\r\n#### Installation ####\r\n\r\n```\r\nnpm install properties\r\n```\r\n\r\n#### Example ####\r\n\r\n```javascript\r\nvar properties = require (\"properties\");\r\n\r\nvar config = {\r\n\tcomment: \"# \",\r\n\tseparator: \" = \",\r\n\tsections: true\r\n};\r\n\r\nvar p = {\r\n\tp1: \"v1\",\r\n\tp2: null,\r\n\tp3: {\r\n\t\t$comment: \"A property\",\r\n\t\t$value: \"v3\"\r\n\t},\r\n\tp4: {\r\n\t\t$comment: \"An empty property\\nwith multi-line comment\"\r\n\t},\r\n\ts1: {\r\n\t\tp1: 1,\r\n\t\tp2: 2\r\n\t}\r\n};\r\n\r\nproperties.store (\"file\", p, config, function (error){\r\n\tif (error) return console.log (error);\r\n\tproperties.load (\"file\", config, function (error, p){\r\n\t\tif (error) return console.log (error);\r\n\t\tconsole.log (p);\r\n\t\t\r\n\t\t/*\r\n\t\tPrints:\r\n\t\t\r\n\t\t{\r\n\t\t\tp1: \"v1\",\r\n\t\t\tp2: null,\r\n\t\t\tp3: \"v3\",\r\n\t\t\tp4: null,\r\n\t\t\ts1: {\r\n\t\t\t\tp1: 1,\r\n\t\t\t\tp2: 2\r\n\t\t\t}\r\n\t\t}\r\n\t\t*/\r\n\t});\r\n});\r\n```\r\n\r\nfile:\r\n\r\n```text\r\np1 = v1\r\np2 = \r\n# A property\r\np3 = v3\r\n# An empty property\r\n# with multi-line comment\r\np4 = \r\n[s1]\r\np1 = 1\r\np2 = 2\r\n```\r\n\r\n#### Features ####\r\n\r\n##### Sections #####\r\n\r\nTo add a section just write:\r\n\r\n`[<name>]`\r\n\r\nExample:\r\n\r\n`[My Section]`\r\n\r\nAdditional information:\r\n\r\n* The keys next to a section header will belong to that section.\r\n* Different sections can have keys with the same name.\r\n* The keys added before the first section are considered global and don't belong to any section.\r\n* It's not possible to nest sections inside other sections.\r\n* A duplicate section replaces the previous section with the same name, they are not merged.\r\n\r\nSections are disabled by default.\r\n\r\n##### Variables #####\r\n\r\nTo get the value of a key:\r\n\r\n```text\r\na = 1\r\nb = ${a}\r\n```\r\n\r\nThe value of `b` will be `1`.\r\n\r\nTake into account that the keys can belong to sections. In the previous example, `a` and `b` are global properties. To reference a key within a section just prefix the section followed by a `|`. Example:\r\n\r\n```text\r\na = 1\r\n[s1]\r\na = 2\r\n[s2]\r\na = 3\r\nb = ${a}${s1|a}${s2|a}\r\n```\r\n\r\nThe value of `b` will be `123`.\r\n\r\nYou can also nest variables inside other variables, in other words, you can create variables dynamically. Example:\r\n\r\n```text\r\n[s1]\r\na = 12\r\n[s2]\r\n123 = a\r\nb = ${s2|${s1|a}3}\r\n```\r\n\r\nThe value of `b` will be `a`.\r\n\r\nYou can use a variable anywhere. Look at the [examples](https://github.com/Gagle/Node-Properties/tree/master/examples/variables) to see what you can do with variables.\r\n\r\nVariables are disabled by default.\r\n\r\n##### Customize tokens #####\r\n\r\nYou can also add new characters that can be used to write comments or to separate keys from values. For example, we want to parse a text that uses `;` to write comments:\r\n\r\n```javascript\r\nproperties.parse (text, { comments: [\";\"] });\r\n```\r\n\r\nThe .properties specification says that `#` and `!` can be used to write comments. These characters will always be allowed, so the `comments` property adds `;` to the valid set of tokens.\r\n\r\nSimilarly, you can add new characters that are parsed as a key-value separator:\r\n\r\n```javascript\r\nproperties.parse (text, { separators: [\"-\", \">\"] });\r\n```\r\n\r\n`comments` and `separators` are used when parsing strings. If you want to stringify an object and write comments with `; ` and separators with ` - ` you have to use `comment` and `separator` properties:\r\n\r\n```javascript\r\nproperties.stringify (text, { comment: \"; \", separator: \" - \" });\r\n```\r\n\r\nTake into account that `comment` and `separator` can contain blank spaces (space, \\t or \\f) but `comments` and `separators` properties expect an array of single characters.\r\n\r\n##### INI files #####\r\n\r\nIf you enable the sections and add `;` to the set of valid comment characters, this module can also parse and stringify INI files:\r\n\r\n```javascript\r\nproperties.parse (text, {\r\n\tsections: true,\r\n\tcomments: [\";\"]\r\n});\r\n\r\nproperties.stringify (obj, {\r\n\tsections: true,\r\n\tcomment: \"; \"\r\n});\r\n```\r\n\r\n#### Methods ####\r\n\r\n- [properties.load(file[, settings], callback)](#load)\r\n- [properties.parse(str[, settings])](#parse)\r\n- [properties.store(file, obj[, settings], callback)](#store)\r\n- [properties.stringify(obj[, settings])](#stringify)\r\n\r\n<a name=\"load\"></a>\r\n__properties.load(file[, settings], callback)__  \r\nLoads a file. The callback receives the error and the loaded properties. The loaded properties are just a JavaScript object in literal notation. The access to the file is buffered.\r\n\r\nThe possible settings are:\r\n\r\n- encoding. _String_. `ascii` or `utf8`. Default is `utf8`.\r\n- bufferSize. _Number_. The buffer size used while reading the file. Default is 16KB.\r\n- comments. _Array_. An array of characters that are used to parse comments. `#` and `!` are always considered comment tokens.\r\n- separators. _Array_. An array of characters that are used to parse key-value separators. `=`, `:` and `<blank space>` are always considered separator tokens.\r\n- sections. _Boolean_. Enables the sections. Default is false.\r\n- variables. _Boolean_. Enables the variables. Default is false.\r\n- reviver. _Function_. Callback executed for each property and section. Its funcionality is similar to the json reviver callback. The reviver receives two parameters, the key and the value. The returned value will be stored in the final object. If the function returns undefined the property is not added. If sections are enabled the reviver receives a third parameter, the section. When a section is found, the key and the value are set to null. The returned value will be used to set section's name, if it's undefined the section is not added.\r\n\r\n  For example, a reviver that does nothing:\r\n\t\r\n\tfile:\r\n\t\r\n\t```text\r\n\ta = 1\r\n\t[section1]\r\n\ta = 1\r\n\t[section2]\r\n\ta = 1\r\n\t```\r\n\r\n\t```javascript\r\n\tvar reviver = function (key, value, section){\r\n\t\tconsole.log (key, value, section);\r\n\t\t\r\n\t\t/*\r\n\t\tPrints:\r\n\t\t\r\n\t\ta 1 null\r\n\t\tnull null section1\r\n\t\ta 1 section1\r\n\t\tnull null section2\r\n\t\ta 1 section2\r\n\t\t*/\r\n\t\t\r\n\t\tif (key === null){\r\n\t\t\t//Section found\r\n\t\t\treturn section;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\t\r\n\tproperties.load (\"file\", { reviver: reviver, sections: true }, function (error, props){\r\n\t\tconsole.log (props);\r\n\t\t\r\n\t\t/*\r\n\t\tPrints:\r\n\t\t\r\n\t\t{\r\n\t\t\ta: 1,\r\n\t\t\tsection1: {\r\n\t\t\t\ta: 1\r\n\t\t\t},\r\n\t\t\tsection2: {\r\n\t\t\t\ta: 1\r\n\t\t\t}\r\n\t\t}\r\n\t\t*/\r\n\t});\r\n\t```\r\n\r\n<a name=\"parse\"></a>\r\n__properties.parse(str[, settings])__  \r\nDoes the same as [load()](#load) but does not perform any I/O access, the input is the given string. The function can throw exceptions when the variables are enabled, otherwise is not necessary to wrap it with a try-catch.\r\n\r\n<a name=\"store\"></a>\r\n__properties.store(file, obj[, settings], callback)__  \r\nStores a JavaScript object in literal notation -the properties- to a file. The callback receives a possible error.\r\n\r\nAll the non printable unicode characters ([C0 and C1 control codes](http://en.wikipedia.org/wiki/C0_and_C1_control_codes): 0-31 and 127-159) are converted to its unicode string representation, e.g. 0x00 (NUL) is converted to \\u0000.\r\n\r\nThe properties can be null and can have comments. To write comments you must use an object with a `$comment` and `$value` properties. Some examples:\r\n\r\n```javascript\r\nvar props = {\r\n\ta: \"a value\",\r\n\tb: null,\r\n\tc: {\r\n\t\t$comment: \"c comment\",\r\n\t\t$value: \"c value\"\r\n\t},\r\n\td: {\r\n\t\t$comment: \"d comment\",\r\n\t\t$value: null\r\n\t},\r\n\te: {\r\n\t\t$comment: \"e comment\"\r\n\t\t//No value, the same as d\r\n\t},\r\n\tf: {\r\n\t\t//No comment, the same as a\r\n\t\t$value: \"f value\"\r\n\t},\r\n\tg: {\r\n\t\t//No comment and no value, the same as b if sections are disabled\r\n\t\t//If sections are enabled this is a section with no properties\r\n\t},\r\n\th: {\r\n\t\t$comment: \"h section\",\r\n\t\t$value: {\r\n\t\t\ta: \"a value\",\r\n\t\t\tb: {\r\n\t\t\t\t$comment: \"b comment\",\r\n\t\t\t\t$value: \"b value\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n```\r\n\r\nThe possible settings are:\r\n- encoding. _String_. `ascii` or `utf8`. If `ascii` is used, all the characters with code greater than 127 are converted to its unicode string representation. Default is `utf8`.\r\n- bufferSize. _Number_. The buffer size used while writing the file. Default is 16KB.\r\n- comment. _String_. The characters used to write comments. Default is `#`.\r\n- separator. _String_. The characters used to separate keys from values. Default is `=`.\r\n- sections. _Boolean_. Enables the sections. Default is false.\r\n- header. _String_. A comment that is written at the beginning of the file.\r\n- pretty. _Boolean_. If true, the stringified properties are pretty printed: tabbed and word wrapped at 80 columns.\r\n- replacer. _Function_. The same as the reviver function but if the returned value is undefined the property or section is not stringified. Receives two parameters and optionally three if sections are enabled.\r\n\r\nThe comments (from properties and header) can be written as a multi-line comments, for example, if you write a property:\r\n\r\n```javascript\r\na: {\r\n\t$comment: \"line 1\\nline2\"\r\n\t$value: \"b\"\r\n}\r\n```\r\n\r\nThen this will be written:\r\n\r\n```text\r\n#line 1\r\n#line 2\r\na=b\r\n```\r\n\r\nThe line separator could also be `\\r\\n`. Line separators are only used to split the comment, that is, if you're on Linux and write a comment `line1\\r\\nline2`, a `\\n` will be used to write these lines.\r\n\r\nPlease, note that the ECMAScript specification does not guarantee the order of the object properties, so this module cannot guarantee that the properties will be stored with the same order. This module guarantees that if sections are enabled, the global properties (properties that doesn't belong to any section) will be written before the sections to avoid possible errors.\r\n\r\n> ECMA-262 does not specify enumeration order. The de facto standard is to match insertion order, which V8 also does, but with one exception:\r\n> V8 gives no guarantees on the enumeration order for array indices (i.e., a property name that can be parsed as a 32-bit unsigned integer).\r\n\r\n<a name=\"stringify\"></a>\r\n__properties.stringify(obj[, settings])__  \r\nDoes the same as [store()](#store) but does not perform any I/O access, the output is a string.",
  "readmeFilename": "README.md",
  "_id": "properties@0.3.3",
  "dist": {
    "shasum": "c815a7d5e0990271749558ac3cd5b5f4b24b0c0c"
  },
  "_from": "properties@",
  "_resolved": "https://registry.npmjs.org/properties/-/properties-0.3.3.tgz"
}
