{
  "name": "buffered-writer",
  "version": "0.2.3",
  "description": "Writes buffered data to files",
  "keywords": [
    "buffer",
    "write",
    "stream",
    "file",
    "binary",
    "data"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gaglekas@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Gagle/Node-BufferedWriter.git"
  },
  "engines": {
    "node": "*"
  },
  "dependencies": {
    "error-provider": "*"
  },
  "devDependencies": {
    "mocha-runner": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.html"
    }
  ],
  "main": "lib/buffered-writer",
  "readme": "buffered-writer\r\n===============\r\n\r\n_Node.js project_\r\n\r\n#### Writes buffered data ####\r\n\r\nVersion: 0.2.3\r\n\r\nNode.js streams are not buffered, that is, when you write data to them you're doing multiple I/O calls. This module buffers the data that has to be written to disk and eases the buffer manipulation when you need to write data from different nature (strings, numbers, arrays or buffers).\r\n\r\n#### Installation ####\r\n\r\n```\r\nnpm install buffered-writer\r\n```\r\n\r\n#### Example ####\r\n\r\n```javascript\r\nvar bw = require (\"buffered-writer\");\r\n\r\nbw.open (\"file\")\r\n\t.on (\"error\", function (error){\r\n\t\tconsole.log (error);\r\n\t})\r\n\t.write ([0x00, 0x01, 0x02]) //Writes: 0x00, 0x01, 0x02\r\n\t.write (new Buffer ([0x03, 0x04]), 1, 1) //Writes: 0x04\r\n\t.write (0x0506) //Writes: 0x05, 0x06\r\n\t.write (\"↑a\", 1) //Writes: a (0x61)\r\n\t.close ();\r\n```\r\n\r\n#### Methods ####\r\n\r\nWhen you call to `open()` a `Writer` instance is returned. This object inherits from `EventEmitter` and wraps a `WriteStream`. Only an `error` event is emitted. When this ocurrs, the `Writer` is closed automatically, you don't need to close it explicitly (if you try to do so you'll get another error, you cannot close twice).\r\n\r\n- [bw.open(file[, settings])](#open)\r\n- [Writer#close([callback])](#close)\r\n- [Writer#flush(callback)](#flush)\r\n- [Writer#line()](#line)\r\n- [Writer#write(data[, offset[, length]])](#write)\r\n- [Writer#writeln(data[, offset[, length]])](#writeln)\r\n\r\n<a name=\"open\"></a>\r\n__bw.open(file[, settings])__  \r\nCreates a `Writer` and opens a stream to the given file. If the file doesn't exist it is created. The possible settings are:\r\n\r\n- bufferSize. _Number_. The buffer size. It must be greater than 0. Default is 16KB.\r\n- encoding. _String_. The file encoding. Is only used when strings are written, that is, this parameter is ignored when you write arrays, numbers or buffers. Default is \"utf8\". Possible values are: \"ascii\", \"utf8\", \"utf16le\", \"ucs2\", \"base64\", \"hex\".\r\n- append. _Boolean_. If true appends the data, if false the file is truncated. Default is false.\r\n- mode. _Number_ | _String_. The file attributes. Default is 0644.\r\n- start. _Number_. The offset to start writing data. Default is 0.\r\n\r\nReturns the new `Writer` instance.\r\n\r\n<a name=\"close\"></a>\r\n__Writer#close([callback])__  \r\nFlushes the remaining data and closes the `Writer`. The callback doesn't receive any parameter.\r\n\r\n<a name=\"flush\"></a>\r\n__Writer#flush(callback)__  \r\nFlushes the current data. After the callback is executed it's safe to read back the written data, the data has been stored successfully. The callback doesn't receive any parameter.\r\n\r\nThis function is typically used when you need to ensure that the data is flushed to the disk at some point before closing the stream.\r\n\r\n```javascript\r\nvar out = bw.open (\"file\").write (\"a\");\r\n//Default buffer size is 16KB so the \"a\" character is still in memory\r\n//Let's force and flush it to disk\r\nout.flush (function (){\r\n\tfs.readFile (\"file\", function (error, data){\r\n\t\tif (error) return console.log (error);\r\n\t\t//data.toString () === \"a\"\r\n\t\tout.close ();\r\n\t});\r\n});\r\n```\r\n\r\n<a name=\"line\"></a>\r\n__Writer#line()__  \r\nWrites a line, OS dependent, `\\r\\n` on Windows, `\\n` otherwise.\r\n\r\nReturns the `Writer` instance to allow method chaining.\r\n\r\n<a name=\"write\"></a>\r\n__Writer#write(data[, offset[, length]])__  \r\nWrites data. It's not flushed to the underlying I/O layer, it's queued to a buffer and when it's full it's flushed to the disk.\r\n\r\nThe data can be a Number, String, Array or Buffer.\r\n- Number. Is stored in big endian, e.g.: 0x0102  will be stored as [0x01, 0x02], 0x01 in a lower address.\r\n- String. The `open()`'s encoding parameter is used.\r\n- Array. An array of numbers. They are stored in the same order.\r\n- Buffer. The Node.js built-in Buffer.\r\n\r\nThe offset and length specifies the slice of the given piece of data that will be written. By default offset is 0 and length is the last byte/character. The offset and length are applied to the string characters, not the bytes, for example, `write(\"↑a\", 1)` will write `a` because offset is 1. Take into account that `↑` is encoded with 3 bytes in utf8.\r\n\r\nReturns the `Writer` instance to allow method chaining.\r\n\r\n<a name=\"writeln\"></a>\r\n__Writer#writeln(data[, offset[, length]])__  \r\nDoes the same as `write()` but stringifies the data and concatenates an EOL, OS dependent, `\\r\\n` on Windows, `\\n` otherwise.",
  "readmeFilename": "README.md",
  "_id": "buffered-writer@0.2.3",
  "dist": {
    "shasum": "6d86e33475a14c4878e1e6d3b774b6eaf185f15a"
  },
  "_from": "buffered-writer@*",
  "_resolved": "https://registry.npmjs.org/buffered-writer/-/buffered-writer-0.2.3.tgz"
}
