{
  "name": "error-provider",
  "version": "0.0.6",
  "description": "Manages errors for third-party modules",
  "keywords": [
    "error",
    "errno",
    "provider",
    "libuv"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gaglekas@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Gagle/Node-ErrorProvider.git"
  },
  "engines": {
    "node": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.html"
    }
  ],
  "main": "lib/error-provider",
  "readme": "error-provider\r\n==============\r\n\r\n_Node.js project_\r\n\r\n#### Manages errors for third-party modules ####\r\n\r\nVersion: 0.0.6\r\n\r\nWhen you're writing a third-party module you'll probably deal with errors. If you want to send custom errors to your users you should send a code and then in your documentation explain these codes.\r\n\r\nThis module eases the error management, you only need to give a number, a code and a description and when you need them just get and throw them.\r\n\r\nThe built-in errors are also available so if you need to manually throw a `EEXIST` you can do so.\r\n\r\nThe error description accepts variables, that is, you can create an error with a variable and when you get it you can set the variable value:\r\n\r\n```javascript\r\nep.create (1000, \"MY_CUSTOM_ERROR\", \"This is a {which} error\");\r\nconsole.log (ep.get (\"MY_CUSTOM_ERROR\", { which: \"custom\" }));\r\n\r\n/*\r\nPrints:\r\n\r\n{ [MY_CUSTOM_ERROR: This is a custom error] errno: 1000, code: \"MY_CUSTOM_ERROR\" }\r\n*/\r\n```\r\n\r\nIf you want to add another property different from `errno`, `code` and `description` you can do it, just pass an object with the new properties (if the property value is a string it can also have variables):\r\n\r\n```javascript\r\nep.create (ep.next (), \"MY_CUSTOM_ERROR\", \"This is a {which} error\", {\r\n\tpath: \"{path}\",\r\n\tfn: function (){\r\n\t\tconsole.log (\"custom error\");\r\n\t}\r\n});\r\nvar error = ep.get (\"MY_CUSTOM_ERROR\", { which: \"custom\", path: \"some/path\" });\r\nerror.fn ();\r\nconsole.log (error);\r\n\r\n/*\r\nPrints:\r\n\r\ncustom error\r\n{ [MY_CUSTOM_ERROR: This is a custom error]\r\n  errno: 100,\r\n  code: \"MY_CUSTOM_ERROR\",\r\n  path: \"some/path\",\r\n  fn: [Function] }\r\n*/\r\n```\r\n\r\n#### Installation ####\r\n\r\n```\r\nnpm install error-provider\r\n```\r\n\r\n#### Example ####\r\n\r\n```javascript\r\nvar ep = require (\"error-provider\");\r\n\r\nconsole.log (ep.get (ep.ENOENT));\r\n\r\nvar n = ep.next ();\r\nep.create (n, \"TEST1\", \"test 1\");\r\nconsole.log (ep.get (ep.TEST1));\r\nconsole.log (ep.get (\"TEST1\"));\r\nconsole.log (ep.get (n));\r\n\r\n/*\r\nPrints:\r\n\r\n{ [ENOENT: no such file or directory] errno: 34, code: \"ENOENT\" }\r\n{ [TEST1: test 1] errno: 100, code: \"TEST1\" }\r\n{ [TEST1: test 1] errno: 100, code: \"TEST1\" }\r\n{ [TEST1: test 1] errno: 100, code: \"TEST1\" }\r\n*/\r\n```\r\n\r\n#### Methods ####\r\n\r\nThere's a special method called `local()` that returns a local error provider. If you need a local storage with custom errors that you don't need to make public, `local()` can help you. If another third-party module uses the `error-provider` module you won't see its errors, the local error provider is local to your module. The first available errno is 0 and the set of default codes is empty, that is, you can't return a built-in error like `EEXIST`. You can create all the storages you want.\r\n\r\n```javascript\r\nvar ep = require (\"error-provider\").local ();\r\nep.create (ep.next (), ...);\r\nep.get (...);\r\n```\r\n\r\n- [ep.create(errno, code, description[, properties])](#create)\r\n- [ep.get(id[, vars])](#get)\r\n- [ep.next()](#next)\r\n\r\n<a name=\"create\"></a>\r\n__ep.create(errno, code, description[, properties])__  \r\nCreates an error with an id, code, description and additional properties.\r\n\r\nThe strings can contain variables that can be set later. A variable is a name encapsulated inside curly braces:\r\n\r\n```javascript\r\nep.create (ep.next (), \"TEST1\", \"test 1\", {\r\n\tpath: \"{p}\"\r\n});\r\nconsole.log (ep.get (\"TEST1\", { p: \"some/path\" }));\r\n\r\n/*\r\nPrints:\r\n\r\n{ [TEST1: test 1] errno: 100, code: \"TEST1\", path: \"some/path\" }\r\n*/\r\n```\r\n\r\n<a name=\"get\"></a>\r\n__ep.get(id[, vars])__  \r\nReturns an error. It can be a Node.js built-in error such as `ENOENT` or one that was created previously.\r\n\r\nThe `id` can be a Number, String or Object:\r\n\r\n```javascript\r\nep.create (ep.next (), \"TEST1\", \"Test 1\");\r\nconsole.log (ep.get (ep.TEST1));\r\nconsole.log (ep.get (\"TEST1\"));\r\nconsole.log (ep.get (100));\r\n```\r\n\r\nIf `vars` is provided, the variables found in the error properties that are String will be set with the given value.\r\n\r\n```javascript\r\nep.create (ep.next (), \"TEST1\", \"test {number}\", {\r\n\tn: \"{number}\",\r\n\tp: \"{value}\"\r\n});\r\nconsole.log (ep.get (\"TEST1\", { number: 1, value: \"ok\" }));\r\n\r\n/*\r\nPrints:\r\n\r\n{ [TEST1: test 1]\r\n  errno: 100,\r\n  code: \"TEST1\",\r\n  n: \"1\",\r\n  p: \"ok\" }\r\n*/\r\n```\r\n\r\n<a name=\"next\"></a>\r\n__ep.next()__  \r\nReturns the next available error number and increments the counter. This number is an identifier to create errors.\r\n\r\nThe first available number starts at 100.\r\n\r\nThe following example creates three errors with identified with 100, 101 and 102.\r\n\r\n```javascript\r\nep.create (ep.next (), ...);\r\nep.create (ep.next (), ...);\r\nep.create (ep.next (), ...);\r\n```",
  "readmeFilename": "README.md",
  "_id": "error-provider@0.0.6",
  "dist": {
    "shasum": "fef0a7c5bba09af50c73188e353d3f713e695a69"
  },
  "_from": "error-provider@*",
  "_resolved": "https://registry.npmjs.org/error-provider/-/error-provider-0.0.6.tgz"
}
